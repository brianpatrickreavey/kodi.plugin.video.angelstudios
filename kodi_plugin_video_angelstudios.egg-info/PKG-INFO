Metadata-Version: 2.4
Name: kodi-plugin-video-angelstudios
Version: 0.4.1
Summary: Kodi plugin for Angel Studios content
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE.txt
Requires-Dist: requests
Requires-Dist: simplecache
Requires-Dist: auth0-ciam-client @ git+https://github.com/brianpatrickreavey/auth0-ciam-client.git@v0.2.1
Provides-Extra: dev
Requires-Dist: flake8; extra == "dev"
Requires-Dist: black; extra == "dev"
Requires-Dist: pyright; extra == "dev"
Requires-Dist: pytest; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: semver; extra == "dev"
Requires-Dist: kodi-addon-builder @ git+https://github.com/brianpatrickreavey/kodi-addon-builder.git ; extra == "dev"
Dynamic: license-file

# angelstudios-kodi
Angel Studios KODI Addon

# Overview

## Playback behavior (current)
- ISA enabled: we pass the master HLS URL and set ISA properties only. `stream_selection_type` is set per addon quality setting (auto→adaptive, fixed heights→fixed-res with chooser caps incl. secure, manual→ask-quality). No manifest prefetch or local filtering.
- ISA unavailable/disabled: we set the master HLS URL as-is for native playback; no prefetch, no variant selection, no manual prompt. If no URL, we log a warning.
- Rationale: keep ISA in control of stream selection while avoiding local manifest handling; keep non-ISA simple and resilient.

# Development and build environment
This project uses `uv` for modern Python dependency management and `kodi-addon-builder` for automated releases.

### Quick Setup
```bash
# Install uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# Clone and setup
git clone https://github.com/yourusername/kodi.plugin.video.angelstudios.git
cd kodi.plugin.video.angelstudios
uv sync --dev

# Run tests
uv run make unittest-with-coverage
```

For detailed development and build instructions, see [BUILD.md](BUILD.md).

# TODO
* Implement correct behavior for unauthenticated users.
  * Most shows should not be viewable without authentication, to match the
  behavoir of the website.  Some limited trailers and previews _are_ available
  without authentication.  Unsure how to identify these.  May have to pull
  the episode page and parse for the login bits.
* Handle bad username/password errors.

# Map of the data

* catalog
  * series
    * project
      * projectType
      * slug
      * public
      * name
      * id
      * metadata
        * contentRating
        * externalLinks
        * genres
      * discoveryPosterCloudinaryPath
      * discoveryPosterLandscapeCloudinaryPath
      * logoCloudinaryPath
      * seasons []
        * id
        * seasonNumber
        * episodes []
          * id
          * guid
          * name
          * episodeNumber


# GraphQL info
It may be more efficient to pull back the entire catalog every time load the app,
but more targeted queries are more inline with the spirit of GraphQL.  We will
break down queries to return just the needed info at the time of the query
even though this may result in a few extra queries to the server.
* NOPE

# Menu Flow
## Main Menu
Generated by calling a basic catalog query, sorting all returned projects by
`projectType`, and returning a menu with those options.

Since we know we want Movies, Series, and Specials, we should just create those
by default and then have a catchall for everything else as Other Content

TODO:
* Livestreams do not show up in this query
* There are other useful menu itmes like favorited, or watched, or whatever
that we see in the website calls that we could add later.
* Would it be faster to do a thinner query for main menu, and a deeper query
in each menu item?  Even though we have to still query for all things, it might
feel more responsive.

### Series
Generated by the data from Main Menu (for now).  We should be able to pass the
blob along with enough detail to not have to call it again.

Create one menu item per project where `projectType == 'series'`.  Should be
able to get images from the blob above, including Logo (used in other KODI
themes).

Menu item should call a Season view if there are >1 Season, otherwise go right
into the single season menu.  This should be replicated across all content
types, actually.  Should be genericized as a build_content_menu function with
a project type, and optional season.  For example:
* call 'tuttle-twins' -> display season menu
* call 'tuttle-twins', 'season 1' -> display content for Season 1
* call 'tuttle-twins-shorts' -> display content for Season 0 (single season)
* call 'tuttle-twins', 'episode_guid' -> play
* call 'shayne-smith-banned-from-karate' -> play content directly
(single season, single episode)

* for Movies, Episodes dont need episode numbers, but should be ordered such
that the movie comes first, then the extra content, and useful names are
given to each.

TODO:
* do series have extras?  where are they?
* do the above programatically.  Don't assume certain things based on the
content type unless absolutely necessary (e.g. renaiming episodes for movies)
* reuse exact queries from website wherever possible to obfuscate that we're
not actually a browser making these calls.
  * looks like we dont have a full catalog or projects call from the website
  but there are no better calls.  We will have to hope a smaller-scoped
  projects call goes unnoticed.


1. get a catalog of all projects.  include seasons, and episodes for counts
  1. cache this, so we can reuse for submenus
  1. includes all graphics needed for projects
    1. skip the 'title' graphics for now, its slowing things down too much
1. when a menu item is chosen (series, specials, movies)
  1. display projects
    1. if the project has >1 season, link to season menu
    1. else if the project has 1 season and >1 episode, link to episode menu
    1. else if the project has 1 season and 1 episode, link to direct play


* main calls "ui helper" to build menus and such
* "ui helper" calls a data interface, which can call the Angel Interface,
or return canned resposnes for testing purposes
* Angel Interface can call the website or return canned responses also (?)

This allows our calls from the ui-helper functions to be cached.  Maybe
these belong in main, though, as i don't see the need to abstract an
additional layer.  Main should be bale to buidl menus and make KODI calls
itself without needing a separate file.

Plan:
* main router
  * main menu -> needs nothing, all canned (films, series, drybar specials,
  livestreams, podcasts, currently watching, other special menus)
  * each menu item, when called, is going to load a function to build that
  particular menu.  it may make calls to a data layer, but not to Angel
  directly.  it should be the data layer that takes the angel output and
  formats it for menu consumption

Questions:
* where does authentication live?  Ideally in the angel layer, but needs to
be able to get credentials, session data from KODI.  Supply from beneath,
or let that layer make calls directly?  Ideally it would be abstracted...
so that the angel library can be used independently.  Needs to be flexible
on where to pull those details from, or handle them natively.
  * e.g. pass along user/pass, and the whole session blob on each instantiation
  or call.  if the session is missing or expired, reauthenticate.  Pass session
  blob back down the chain to be saved.
  * actually, this is what we're currently doing, so that should be fine.
* Does the data layer ever interact with KODI directly?  If not, then data layer
instatiation needs to get user/pass/session from main.

maybe the main calls both the data layer and angel interface, and passes the
angel interface on to the data layer to make use of.  that seems cleaner
than passing things `main -> data layer -> angel interface`.




new plan:
* main menu:
  * movies, series, specials are lists of projects.  Call the projects handler
    * for each project after filtering, call the project_seasons handler
      1. if has >1 seasons, display seasons, else call episode_menu
      2. if has >1 episodes, display episodes, else call play






Build a catalog cache as the queries are made, and then check for missing data
in the cache before making another query.  This might be doable with the
native KODI caching if we're resuing the exact same function calls, but it
might work better if we do it ourselves.

Cache is somewhat working - need to check which queries get us extra
information (e.g. does the project query get us all the seasons and episodes
as well), and pre-cache those results so that they are immediately available
when a project or season is selected.

Also, it seems we're doing quite a bit to validate the session on every call.
This can be much simpler if we just try to make the call, and re-authenticate
and retry the call if the session had timed out (check error messages).
